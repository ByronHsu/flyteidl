// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/core/literals.proto

#ifndef PROTOBUF_flyteidl_2fcore_2fliterals_2eproto__INCLUDED
#define PROTOBUF_flyteidl_2fcore_2fliterals_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
#include "flyteidl/core/types.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_flyteidl_2fcore_2fliterals_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[18];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPrimitiveImpl();
void InitDefaultsPrimitive();
void InitDefaultsVoidImpl();
void InitDefaultsVoid();
void InitDefaultsBlobImpl();
void InitDefaultsBlob();
void InitDefaultsBlobMetadataImpl();
void InitDefaultsBlobMetadata();
void InitDefaultsBinaryImpl();
void InitDefaultsBinary();
void InitDefaultsSchemaImpl();
void InitDefaultsSchema();
void InitDefaultsScalarImpl();
void InitDefaultsScalar();
void InitDefaultsLiteralImpl();
void InitDefaultsLiteral();
void InitDefaultsBindingDataImpl();
void InitDefaultsBindingData();
void InitDefaultsBindingImpl();
void InitDefaultsBinding();
void InitDefaultsKeyValuePairImpl();
void InitDefaultsKeyValuePair();
void InitDefaultsRetryStrategyImpl();
void InitDefaultsRetryStrategy();
inline void InitDefaults() {
  InitDefaultsPrimitive();
  InitDefaultsVoid();
  InitDefaultsBlob();
  InitDefaultsBlobMetadata();
  InitDefaultsBinary();
  InitDefaultsSchema();
  InitDefaultsScalar();
  InitDefaultsLiteral();
  InitDefaultsBindingData();
  InitDefaultsBinding();
  InitDefaultsKeyValuePair();
  InitDefaultsRetryStrategy();
}
}  // namespace protobuf_flyteidl_2fcore_2fliterals_2eproto
namespace flyteidl {
namespace core {
class Binary;
class BinaryDefaultTypeInternal;
extern BinaryDefaultTypeInternal _Binary_default_instance_;
class Binding;
class BindingDefaultTypeInternal;
extern BindingDefaultTypeInternal _Binding_default_instance_;
class BindingData;
class BindingDataDefaultTypeInternal;
extern BindingDataDefaultTypeInternal _BindingData_default_instance_;
class BindingDataCollection;
class BindingDataCollectionDefaultTypeInternal;
extern BindingDataCollectionDefaultTypeInternal _BindingDataCollection_default_instance_;
class BindingDataMap;
class BindingDataMapDefaultTypeInternal;
extern BindingDataMapDefaultTypeInternal _BindingDataMap_default_instance_;
class BindingDataMap_BindingsEntry_DoNotUse;
class BindingDataMap_BindingsEntry_DoNotUseDefaultTypeInternal;
extern BindingDataMap_BindingsEntry_DoNotUseDefaultTypeInternal _BindingDataMap_BindingsEntry_DoNotUse_default_instance_;
class Blob;
class BlobDefaultTypeInternal;
extern BlobDefaultTypeInternal _Blob_default_instance_;
class BlobMetadata;
class BlobMetadataDefaultTypeInternal;
extern BlobMetadataDefaultTypeInternal _BlobMetadata_default_instance_;
class KeyValuePair;
class KeyValuePairDefaultTypeInternal;
extern KeyValuePairDefaultTypeInternal _KeyValuePair_default_instance_;
class Literal;
class LiteralDefaultTypeInternal;
extern LiteralDefaultTypeInternal _Literal_default_instance_;
class LiteralCollection;
class LiteralCollectionDefaultTypeInternal;
extern LiteralCollectionDefaultTypeInternal _LiteralCollection_default_instance_;
class LiteralMap;
class LiteralMapDefaultTypeInternal;
extern LiteralMapDefaultTypeInternal _LiteralMap_default_instance_;
class LiteralMap_LiteralsEntry_DoNotUse;
class LiteralMap_LiteralsEntry_DoNotUseDefaultTypeInternal;
extern LiteralMap_LiteralsEntry_DoNotUseDefaultTypeInternal _LiteralMap_LiteralsEntry_DoNotUse_default_instance_;
class Primitive;
class PrimitiveDefaultTypeInternal;
extern PrimitiveDefaultTypeInternal _Primitive_default_instance_;
class RetryStrategy;
class RetryStrategyDefaultTypeInternal;
extern RetryStrategyDefaultTypeInternal _RetryStrategy_default_instance_;
class Scalar;
class ScalarDefaultTypeInternal;
extern ScalarDefaultTypeInternal _Scalar_default_instance_;
class Schema;
class SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class Void;
class VoidDefaultTypeInternal;
extern VoidDefaultTypeInternal _Void_default_instance_;
}  // namespace core
}  // namespace flyteidl
namespace flyteidl {
namespace core {

// ===================================================================

class Primitive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Primitive) */ {
 public:
  Primitive();
  virtual ~Primitive();

  Primitive(const Primitive& from);

  inline Primitive& operator=(const Primitive& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Primitive(Primitive&& from) noexcept
    : Primitive() {
    *this = ::std::move(from);
  }

  inline Primitive& operator=(Primitive&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Primitive& default_instance();

  enum ValueCase {
    kInteger = 1,
    kFloatValue = 2,
    kStringValue = 3,
    kBoolean = 4,
    kDatetime = 5,
    kDuration = 6,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Primitive* internal_default_instance() {
    return reinterpret_cast<const Primitive*>(
               &_Primitive_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Primitive* other);
  friend void swap(Primitive& a, Primitive& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Primitive* New() const PROTOBUF_FINAL { return New(NULL); }

  Primitive* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Primitive& from);
  void MergeFrom(const Primitive& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Primitive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 integer = 1;
  private:
  bool has_integer() const;
  public:
  void clear_integer();
  static const int kIntegerFieldNumber = 1;
  ::google::protobuf::int64 integer() const;
  void set_integer(::google::protobuf::int64 value);

  // double float_value = 2;
  private:
  bool has_float_value() const;
  public:
  void clear_float_value();
  static const int kFloatValueFieldNumber = 2;
  double float_value() const;
  void set_float_value(double value);

  // string string_value = 3;
  private:
  bool has_string_value() const;
  public:
  void clear_string_value();
  static const int kStringValueFieldNumber = 3;
  const ::std::string& string_value() const;
  void set_string_value(const ::std::string& value);
  #if LANG_CXX11
  void set_string_value(::std::string&& value);
  #endif
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  ::std::string* mutable_string_value();
  ::std::string* release_string_value();
  void set_allocated_string_value(::std::string* string_value);

  // bool boolean = 4;
  private:
  bool has_boolean() const;
  public:
  void clear_boolean();
  static const int kBooleanFieldNumber = 4;
  bool boolean() const;
  void set_boolean(bool value);

  // .google.protobuf.Timestamp datetime = 5;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDatetimeFieldNumber = 5;
  const ::google::protobuf::Timestamp& datetime() const;
  ::google::protobuf::Timestamp* release_datetime();
  ::google::protobuf::Timestamp* mutable_datetime();
  void set_allocated_datetime(::google::protobuf::Timestamp* datetime);

  // .google.protobuf.Duration duration = 6;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 6;
  const ::google::protobuf::Duration& duration() const;
  ::google::protobuf::Duration* release_duration();
  ::google::protobuf::Duration* mutable_duration();
  void set_allocated_duration(::google::protobuf::Duration* duration);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.Primitive)
 private:
  void set_has_integer();
  void set_has_float_value();
  void set_has_string_value();
  void set_has_boolean();
  void set_has_datetime();
  void set_has_duration();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::int64 integer_;
    double float_value_;
    ::google::protobuf::internal::ArenaStringPtr string_value_;
    bool boolean_;
    ::google::protobuf::Timestamp* datetime_;
    ::google::protobuf::Duration* duration_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsPrimitiveImpl();
};
// -------------------------------------------------------------------

class Void : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Void) */ {
 public:
  Void();
  virtual ~Void();

  Void(const Void& from);

  inline Void& operator=(const Void& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Void(Void&& from) noexcept
    : Void() {
    *this = ::std::move(from);
  }

  inline Void& operator=(Void&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Void& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Void* internal_default_instance() {
    return reinterpret_cast<const Void*>(
               &_Void_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Void* other);
  friend void swap(Void& a, Void& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Void* New() const PROTOBUF_FINAL { return New(NULL); }

  Void* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Void& from);
  void MergeFrom(const Void& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Void* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.core.Void)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsVoidImpl();
};
// -------------------------------------------------------------------

class Blob : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Blob) */ {
 public:
  Blob();
  virtual ~Blob();

  Blob(const Blob& from);

  inline Blob& operator=(const Blob& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Blob(Blob&& from) noexcept
    : Blob() {
    *this = ::std::move(from);
  }

  inline Blob& operator=(Blob&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Blob& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Blob* internal_default_instance() {
    return reinterpret_cast<const Blob*>(
               &_Blob_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Blob* other);
  friend void swap(Blob& a, Blob& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Blob* New() const PROTOBUF_FINAL { return New(NULL); }

  Blob* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Blob& from);
  void MergeFrom(const Blob& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Blob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uri = 3;
  void clear_uri();
  static const int kUriFieldNumber = 3;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // .flyteidl.core.BlobMetadata metadata = 1;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 1;
  const ::flyteidl::core::BlobMetadata& metadata() const;
  ::flyteidl::core::BlobMetadata* release_metadata();
  ::flyteidl::core::BlobMetadata* mutable_metadata();
  void set_allocated_metadata(::flyteidl::core::BlobMetadata* metadata);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Blob)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::flyteidl::core::BlobMetadata* metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsBlobImpl();
};
// -------------------------------------------------------------------

class BlobMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.BlobMetadata) */ {
 public:
  BlobMetadata();
  virtual ~BlobMetadata();

  BlobMetadata(const BlobMetadata& from);

  inline BlobMetadata& operator=(const BlobMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlobMetadata(BlobMetadata&& from) noexcept
    : BlobMetadata() {
    *this = ::std::move(from);
  }

  inline BlobMetadata& operator=(BlobMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlobMetadata* internal_default_instance() {
    return reinterpret_cast<const BlobMetadata*>(
               &_BlobMetadata_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(BlobMetadata* other);
  friend void swap(BlobMetadata& a, BlobMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlobMetadata* New() const PROTOBUF_FINAL { return New(NULL); }

  BlobMetadata* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlobMetadata& from);
  void MergeFrom(const BlobMetadata& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlobMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.BlobType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::flyteidl::core::BlobType& type() const;
  ::flyteidl::core::BlobType* release_type();
  ::flyteidl::core::BlobType* mutable_type();
  void set_allocated_type(::flyteidl::core::BlobType* type);

  // @@protoc_insertion_point(class_scope:flyteidl.core.BlobMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::BlobType* type_;
  mutable int _cached_size_;
  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsBlobMetadataImpl();
};
// -------------------------------------------------------------------

class Binary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Binary) */ {
 public:
  Binary();
  virtual ~Binary();

  Binary(const Binary& from);

  inline Binary& operator=(const Binary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Binary(Binary&& from) noexcept
    : Binary() {
    *this = ::std::move(from);
  }

  inline Binary& operator=(Binary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Binary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Binary* internal_default_instance() {
    return reinterpret_cast<const Binary*>(
               &_Binary_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Binary* other);
  friend void swap(Binary& a, Binary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Binary* New() const PROTOBUF_FINAL { return New(NULL); }

  Binary* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Binary& from);
  void MergeFrom(const Binary& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Binary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string tag = 2;
  void clear_tag();
  static const int kTagFieldNumber = 2;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_tag(::std::string&& value);
  #endif
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Binary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  mutable int _cached_size_;
  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsBinaryImpl();
};
// -------------------------------------------------------------------

class Schema : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Schema) */ {
 public:
  Schema();
  virtual ~Schema();

  Schema(const Schema& from);

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(Schema&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Schema& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Schema* other);
  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Schema* New() const PROTOBUF_FINAL { return New(NULL); }

  Schema* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Schema& from);
  void MergeFrom(const Schema& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Schema* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uri = 1;
  void clear_uri();
  static const int kUriFieldNumber = 1;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // .flyteidl.core.SchemaType type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::flyteidl::core::SchemaType& type() const;
  ::flyteidl::core::SchemaType* release_type();
  ::flyteidl::core::SchemaType* mutable_type();
  void set_allocated_type(::flyteidl::core::SchemaType* type);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Schema)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::flyteidl::core::SchemaType* type_;
  mutable int _cached_size_;
  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsSchemaImpl();
};
// -------------------------------------------------------------------

class Scalar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Scalar) */ {
 public:
  Scalar();
  virtual ~Scalar();

  Scalar(const Scalar& from);

  inline Scalar& operator=(const Scalar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scalar(Scalar&& from) noexcept
    : Scalar() {
    *this = ::std::move(from);
  }

  inline Scalar& operator=(Scalar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scalar& default_instance();

  enum ValueCase {
    kPrimitive = 1,
    kBlob = 2,
    kBinary = 3,
    kSchema = 4,
    kNoneType = 5,
    kError = 6,
    kGeneric = 7,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scalar* internal_default_instance() {
    return reinterpret_cast<const Scalar*>(
               &_Scalar_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Scalar* other);
  friend void swap(Scalar& a, Scalar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scalar* New() const PROTOBUF_FINAL { return New(NULL); }

  Scalar* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Scalar& from);
  void MergeFrom(const Scalar& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Scalar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Primitive primitive = 1;
  bool has_primitive() const;
  void clear_primitive();
  static const int kPrimitiveFieldNumber = 1;
  const ::flyteidl::core::Primitive& primitive() const;
  ::flyteidl::core::Primitive* release_primitive();
  ::flyteidl::core::Primitive* mutable_primitive();
  void set_allocated_primitive(::flyteidl::core::Primitive* primitive);

  // .flyteidl.core.Blob blob = 2;
  bool has_blob() const;
  void clear_blob();
  static const int kBlobFieldNumber = 2;
  const ::flyteidl::core::Blob& blob() const;
  ::flyteidl::core::Blob* release_blob();
  ::flyteidl::core::Blob* mutable_blob();
  void set_allocated_blob(::flyteidl::core::Blob* blob);

  // .flyteidl.core.Binary binary = 3;
  bool has_binary() const;
  void clear_binary();
  static const int kBinaryFieldNumber = 3;
  const ::flyteidl::core::Binary& binary() const;
  ::flyteidl::core::Binary* release_binary();
  ::flyteidl::core::Binary* mutable_binary();
  void set_allocated_binary(::flyteidl::core::Binary* binary);

  // .flyteidl.core.Schema schema = 4;
  bool has_schema() const;
  void clear_schema();
  static const int kSchemaFieldNumber = 4;
  const ::flyteidl::core::Schema& schema() const;
  ::flyteidl::core::Schema* release_schema();
  ::flyteidl::core::Schema* mutable_schema();
  void set_allocated_schema(::flyteidl::core::Schema* schema);

  // .flyteidl.core.Void none_type = 5;
  bool has_none_type() const;
  void clear_none_type();
  static const int kNoneTypeFieldNumber = 5;
  const ::flyteidl::core::Void& none_type() const;
  ::flyteidl::core::Void* release_none_type();
  ::flyteidl::core::Void* mutable_none_type();
  void set_allocated_none_type(::flyteidl::core::Void* none_type);

  // .flyteidl.core.Error error = 6;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 6;
  const ::flyteidl::core::Error& error() const;
  ::flyteidl::core::Error* release_error();
  ::flyteidl::core::Error* mutable_error();
  void set_allocated_error(::flyteidl::core::Error* error);

  // .google.protobuf.Struct generic = 7;
  bool has_generic() const;
  void clear_generic();
  static const int kGenericFieldNumber = 7;
  const ::google::protobuf::Struct& generic() const;
  ::google::protobuf::Struct* release_generic();
  ::google::protobuf::Struct* mutable_generic();
  void set_allocated_generic(::google::protobuf::Struct* generic);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.Scalar)
 private:
  void set_has_primitive();
  void set_has_blob();
  void set_has_binary();
  void set_has_schema();
  void set_has_none_type();
  void set_has_error();
  void set_has_generic();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::flyteidl::core::Primitive* primitive_;
    ::flyteidl::core::Blob* blob_;
    ::flyteidl::core::Binary* binary_;
    ::flyteidl::core::Schema* schema_;
    ::flyteidl::core::Void* none_type_;
    ::flyteidl::core::Error* error_;
    ::google::protobuf::Struct* generic_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsScalarImpl();
};
// -------------------------------------------------------------------

class Literal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Literal) */ {
 public:
  Literal();
  virtual ~Literal();

  Literal(const Literal& from);

  inline Literal& operator=(const Literal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Literal(Literal&& from) noexcept
    : Literal() {
    *this = ::std::move(from);
  }

  inline Literal& operator=(Literal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Literal& default_instance();

  enum ValueCase {
    kScalar = 1,
    kCollection = 2,
    kMap = 3,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Literal* internal_default_instance() {
    return reinterpret_cast<const Literal*>(
               &_Literal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Literal* other);
  friend void swap(Literal& a, Literal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Literal* New() const PROTOBUF_FINAL { return New(NULL); }

  Literal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Literal& from);
  void MergeFrom(const Literal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Literal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Scalar scalar = 1;
  bool has_scalar() const;
  void clear_scalar();
  static const int kScalarFieldNumber = 1;
  const ::flyteidl::core::Scalar& scalar() const;
  ::flyteidl::core::Scalar* release_scalar();
  ::flyteidl::core::Scalar* mutable_scalar();
  void set_allocated_scalar(::flyteidl::core::Scalar* scalar);

  // .flyteidl.core.LiteralCollection collection = 2;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::flyteidl::core::LiteralCollection& collection() const;
  ::flyteidl::core::LiteralCollection* release_collection();
  ::flyteidl::core::LiteralCollection* mutable_collection();
  void set_allocated_collection(::flyteidl::core::LiteralCollection* collection);

  // .flyteidl.core.LiteralMap map = 3;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 3;
  const ::flyteidl::core::LiteralMap& map() const;
  ::flyteidl::core::LiteralMap* release_map();
  ::flyteidl::core::LiteralMap* mutable_map();
  void set_allocated_map(::flyteidl::core::LiteralMap* map);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.Literal)
 private:
  void set_has_scalar();
  void set_has_collection();
  void set_has_map();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::flyteidl::core::Scalar* scalar_;
    ::flyteidl::core::LiteralCollection* collection_;
    ::flyteidl::core::LiteralMap* map_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsLiteralImpl();
};
// -------------------------------------------------------------------

class LiteralCollection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.LiteralCollection) */ {
 public:
  LiteralCollection();
  virtual ~LiteralCollection();

  LiteralCollection(const LiteralCollection& from);

  inline LiteralCollection& operator=(const LiteralCollection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LiteralCollection(LiteralCollection&& from) noexcept
    : LiteralCollection() {
    *this = ::std::move(from);
  }

  inline LiteralCollection& operator=(LiteralCollection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LiteralCollection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LiteralCollection* internal_default_instance() {
    return reinterpret_cast<const LiteralCollection*>(
               &_LiteralCollection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(LiteralCollection* other);
  friend void swap(LiteralCollection& a, LiteralCollection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LiteralCollection* New() const PROTOBUF_FINAL { return New(NULL); }

  LiteralCollection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LiteralCollection& from);
  void MergeFrom(const LiteralCollection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LiteralCollection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.core.Literal literals = 1;
  int literals_size() const;
  void clear_literals();
  static const int kLiteralsFieldNumber = 1;
  const ::flyteidl::core::Literal& literals(int index) const;
  ::flyteidl::core::Literal* mutable_literals(int index);
  ::flyteidl::core::Literal* add_literals();
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Literal >*
      mutable_literals();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Literal >&
      literals() const;

  // @@protoc_insertion_point(class_scope:flyteidl.core.LiteralCollection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Literal > literals_;
  mutable int _cached_size_;
  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsLiteralImpl();
};
// -------------------------------------------------------------------

class LiteralMap_LiteralsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<LiteralMap_LiteralsEntry_DoNotUse, 
    ::std::string, ::flyteidl::core::Literal,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<LiteralMap_LiteralsEntry_DoNotUse, 
    ::std::string, ::flyteidl::core::Literal,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  LiteralMap_LiteralsEntry_DoNotUse();
  LiteralMap_LiteralsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const LiteralMap_LiteralsEntry_DoNotUse& other);
  static const LiteralMap_LiteralsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LiteralMap_LiteralsEntry_DoNotUse*>(&_LiteralMap_LiteralsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class LiteralMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.LiteralMap) */ {
 public:
  LiteralMap();
  virtual ~LiteralMap();

  LiteralMap(const LiteralMap& from);

  inline LiteralMap& operator=(const LiteralMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LiteralMap(LiteralMap&& from) noexcept
    : LiteralMap() {
    *this = ::std::move(from);
  }

  inline LiteralMap& operator=(LiteralMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LiteralMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LiteralMap* internal_default_instance() {
    return reinterpret_cast<const LiteralMap*>(
               &_LiteralMap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(LiteralMap* other);
  friend void swap(LiteralMap& a, LiteralMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LiteralMap* New() const PROTOBUF_FINAL { return New(NULL); }

  LiteralMap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LiteralMap& from);
  void MergeFrom(const LiteralMap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LiteralMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .flyteidl.core.Literal> literals = 1;
  int literals_size() const;
  void clear_literals();
  static const int kLiteralsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::flyteidl::core::Literal >&
      literals() const;
  ::google::protobuf::Map< ::std::string, ::flyteidl::core::Literal >*
      mutable_literals();

  // @@protoc_insertion_point(class_scope:flyteidl.core.LiteralMap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      LiteralMap_LiteralsEntry_DoNotUse,
      ::std::string, ::flyteidl::core::Literal,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > literals_;
  mutable int _cached_size_;
  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsLiteralImpl();
};
// -------------------------------------------------------------------

class BindingDataCollection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.BindingDataCollection) */ {
 public:
  BindingDataCollection();
  virtual ~BindingDataCollection();

  BindingDataCollection(const BindingDataCollection& from);

  inline BindingDataCollection& operator=(const BindingDataCollection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BindingDataCollection(BindingDataCollection&& from) noexcept
    : BindingDataCollection() {
    *this = ::std::move(from);
  }

  inline BindingDataCollection& operator=(BindingDataCollection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BindingDataCollection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BindingDataCollection* internal_default_instance() {
    return reinterpret_cast<const BindingDataCollection*>(
               &_BindingDataCollection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(BindingDataCollection* other);
  friend void swap(BindingDataCollection& a, BindingDataCollection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BindingDataCollection* New() const PROTOBUF_FINAL { return New(NULL); }

  BindingDataCollection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindingDataCollection& from);
  void MergeFrom(const BindingDataCollection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindingDataCollection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.core.BindingData bindings = 1;
  int bindings_size() const;
  void clear_bindings();
  static const int kBindingsFieldNumber = 1;
  const ::flyteidl::core::BindingData& bindings(int index) const;
  ::flyteidl::core::BindingData* mutable_bindings(int index);
  ::flyteidl::core::BindingData* add_bindings();
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::BindingData >*
      mutable_bindings();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::BindingData >&
      bindings() const;

  // @@protoc_insertion_point(class_scope:flyteidl.core.BindingDataCollection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::BindingData > bindings_;
  mutable int _cached_size_;
  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsBindingDataImpl();
};
// -------------------------------------------------------------------

class BindingDataMap_BindingsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<BindingDataMap_BindingsEntry_DoNotUse, 
    ::std::string, ::flyteidl::core::BindingData,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<BindingDataMap_BindingsEntry_DoNotUse, 
    ::std::string, ::flyteidl::core::BindingData,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  BindingDataMap_BindingsEntry_DoNotUse();
  BindingDataMap_BindingsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const BindingDataMap_BindingsEntry_DoNotUse& other);
  static const BindingDataMap_BindingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BindingDataMap_BindingsEntry_DoNotUse*>(&_BindingDataMap_BindingsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class BindingDataMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.BindingDataMap) */ {
 public:
  BindingDataMap();
  virtual ~BindingDataMap();

  BindingDataMap(const BindingDataMap& from);

  inline BindingDataMap& operator=(const BindingDataMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BindingDataMap(BindingDataMap&& from) noexcept
    : BindingDataMap() {
    *this = ::std::move(from);
  }

  inline BindingDataMap& operator=(BindingDataMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BindingDataMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BindingDataMap* internal_default_instance() {
    return reinterpret_cast<const BindingDataMap*>(
               &_BindingDataMap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(BindingDataMap* other);
  friend void swap(BindingDataMap& a, BindingDataMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BindingDataMap* New() const PROTOBUF_FINAL { return New(NULL); }

  BindingDataMap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindingDataMap& from);
  void MergeFrom(const BindingDataMap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindingDataMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .flyteidl.core.BindingData> bindings = 1;
  int bindings_size() const;
  void clear_bindings();
  static const int kBindingsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::flyteidl::core::BindingData >&
      bindings() const;
  ::google::protobuf::Map< ::std::string, ::flyteidl::core::BindingData >*
      mutable_bindings();

  // @@protoc_insertion_point(class_scope:flyteidl.core.BindingDataMap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      BindingDataMap_BindingsEntry_DoNotUse,
      ::std::string, ::flyteidl::core::BindingData,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > bindings_;
  mutable int _cached_size_;
  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsBindingDataImpl();
};
// -------------------------------------------------------------------

class BindingData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.BindingData) */ {
 public:
  BindingData();
  virtual ~BindingData();

  BindingData(const BindingData& from);

  inline BindingData& operator=(const BindingData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BindingData(BindingData&& from) noexcept
    : BindingData() {
    *this = ::std::move(from);
  }

  inline BindingData& operator=(BindingData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BindingData& default_instance();

  enum ValueCase {
    kScalar = 1,
    kCollection = 2,
    kPromise = 3,
    kMap = 4,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BindingData* internal_default_instance() {
    return reinterpret_cast<const BindingData*>(
               &_BindingData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(BindingData* other);
  friend void swap(BindingData& a, BindingData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BindingData* New() const PROTOBUF_FINAL { return New(NULL); }

  BindingData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindingData& from);
  void MergeFrom(const BindingData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindingData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Scalar scalar = 1;
  bool has_scalar() const;
  void clear_scalar();
  static const int kScalarFieldNumber = 1;
  const ::flyteidl::core::Scalar& scalar() const;
  ::flyteidl::core::Scalar* release_scalar();
  ::flyteidl::core::Scalar* mutable_scalar();
  void set_allocated_scalar(::flyteidl::core::Scalar* scalar);

  // .flyteidl.core.BindingDataCollection collection = 2;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  const ::flyteidl::core::BindingDataCollection& collection() const;
  ::flyteidl::core::BindingDataCollection* release_collection();
  ::flyteidl::core::BindingDataCollection* mutable_collection();
  void set_allocated_collection(::flyteidl::core::BindingDataCollection* collection);

  // .flyteidl.core.OutputReference promise = 3;
  bool has_promise() const;
  void clear_promise();
  static const int kPromiseFieldNumber = 3;
  const ::flyteidl::core::OutputReference& promise() const;
  ::flyteidl::core::OutputReference* release_promise();
  ::flyteidl::core::OutputReference* mutable_promise();
  void set_allocated_promise(::flyteidl::core::OutputReference* promise);

  // .flyteidl.core.BindingDataMap map = 4;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 4;
  const ::flyteidl::core::BindingDataMap& map() const;
  ::flyteidl::core::BindingDataMap* release_map();
  ::flyteidl::core::BindingDataMap* mutable_map();
  void set_allocated_map(::flyteidl::core::BindingDataMap* map);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.BindingData)
 private:
  void set_has_scalar();
  void set_has_collection();
  void set_has_promise();
  void set_has_map();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::flyteidl::core::Scalar* scalar_;
    ::flyteidl::core::BindingDataCollection* collection_;
    ::flyteidl::core::OutputReference* promise_;
    ::flyteidl::core::BindingDataMap* map_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsBindingDataImpl();
};
// -------------------------------------------------------------------

class Binding : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Binding) */ {
 public:
  Binding();
  virtual ~Binding();

  Binding(const Binding& from);

  inline Binding& operator=(const Binding& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Binding(Binding&& from) noexcept
    : Binding() {
    *this = ::std::move(from);
  }

  inline Binding& operator=(Binding&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Binding& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Binding* internal_default_instance() {
    return reinterpret_cast<const Binding*>(
               &_Binding_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Binding* other);
  friend void swap(Binding& a, Binding& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Binding* New() const PROTOBUF_FINAL { return New(NULL); }

  Binding* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Binding& from);
  void MergeFrom(const Binding& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Binding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string var = 1;
  void clear_var();
  static const int kVarFieldNumber = 1;
  const ::std::string& var() const;
  void set_var(const ::std::string& value);
  #if LANG_CXX11
  void set_var(::std::string&& value);
  #endif
  void set_var(const char* value);
  void set_var(const char* value, size_t size);
  ::std::string* mutable_var();
  ::std::string* release_var();
  void set_allocated_var(::std::string* var);

  // .flyteidl.core.BindingData binding = 2;
  bool has_binding() const;
  void clear_binding();
  static const int kBindingFieldNumber = 2;
  const ::flyteidl::core::BindingData& binding() const;
  ::flyteidl::core::BindingData* release_binding();
  ::flyteidl::core::BindingData* mutable_binding();
  void set_allocated_binding(::flyteidl::core::BindingData* binding);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Binding)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr var_;
  ::flyteidl::core::BindingData* binding_;
  mutable int _cached_size_;
  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsBindingImpl();
};
// -------------------------------------------------------------------

class KeyValuePair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.KeyValuePair) */ {
 public:
  KeyValuePair();
  virtual ~KeyValuePair();

  KeyValuePair(const KeyValuePair& from);

  inline KeyValuePair& operator=(const KeyValuePair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValuePair(KeyValuePair&& from) noexcept
    : KeyValuePair() {
    *this = ::std::move(from);
  }

  inline KeyValuePair& operator=(KeyValuePair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValuePair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyValuePair* internal_default_instance() {
    return reinterpret_cast<const KeyValuePair*>(
               &_KeyValuePair_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(KeyValuePair* other);
  friend void swap(KeyValuePair& a, KeyValuePair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValuePair* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyValuePair* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyValuePair& from);
  void MergeFrom(const KeyValuePair& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyValuePair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.KeyValuePair)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsKeyValuePairImpl();
};
// -------------------------------------------------------------------

class RetryStrategy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.RetryStrategy) */ {
 public:
  RetryStrategy();
  virtual ~RetryStrategy();

  RetryStrategy(const RetryStrategy& from);

  inline RetryStrategy& operator=(const RetryStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RetryStrategy(RetryStrategy&& from) noexcept
    : RetryStrategy() {
    *this = ::std::move(from);
  }

  inline RetryStrategy& operator=(RetryStrategy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RetryStrategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RetryStrategy* internal_default_instance() {
    return reinterpret_cast<const RetryStrategy*>(
               &_RetryStrategy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(RetryStrategy* other);
  friend void swap(RetryStrategy& a, RetryStrategy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RetryStrategy* New() const PROTOBUF_FINAL { return New(NULL); }

  RetryStrategy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RetryStrategy& from);
  void MergeFrom(const RetryStrategy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RetryStrategy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 retries = 5;
  void clear_retries();
  static const int kRetriesFieldNumber = 5;
  ::google::protobuf::uint32 retries() const;
  void set_retries(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.RetryStrategy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 retries_;
  mutable int _cached_size_;
  friend struct ::protobuf_flyteidl_2fcore_2fliterals_2eproto::TableStruct;
  friend void ::protobuf_flyteidl_2fcore_2fliterals_2eproto::InitDefaultsRetryStrategyImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Primitive

// int64 integer = 1;
inline bool Primitive::has_integer() const {
  return value_case() == kInteger;
}
inline void Primitive::set_has_integer() {
  _oneof_case_[0] = kInteger;
}
inline void Primitive::clear_integer() {
  if (has_integer()) {
    value_.integer_ = GOOGLE_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 Primitive::integer() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.integer)
  if (has_integer()) {
    return value_.integer_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Primitive::set_integer(::google::protobuf::int64 value) {
  if (!has_integer()) {
    clear_value();
    set_has_integer();
  }
  value_.integer_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.integer)
}

// double float_value = 2;
inline bool Primitive::has_float_value() const {
  return value_case() == kFloatValue;
}
inline void Primitive::set_has_float_value() {
  _oneof_case_[0] = kFloatValue;
}
inline void Primitive::clear_float_value() {
  if (has_float_value()) {
    value_.float_value_ = 0;
    clear_has_value();
  }
}
inline double Primitive::float_value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.float_value)
  if (has_float_value()) {
    return value_.float_value_;
  }
  return 0;
}
inline void Primitive::set_float_value(double value) {
  if (!has_float_value()) {
    clear_value();
    set_has_float_value();
  }
  value_.float_value_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.float_value)
}

// string string_value = 3;
inline bool Primitive::has_string_value() const {
  return value_case() == kStringValue;
}
inline void Primitive::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void Primitive::clear_string_value() {
  if (has_string_value()) {
    value_.string_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& Primitive::string_value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.string_value)
  if (has_string_value()) {
    return value_.string_value_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Primitive::set_string_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.string_value)
}
#if LANG_CXX11
inline void Primitive::set_string_value(::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Primitive.string_value)
}
#endif
inline void Primitive::set_string_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Primitive.string_value)
}
inline void Primitive::set_string_value(const char* value, size_t size) {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Primitive.string_value)
}
inline ::std::string* Primitive::mutable_string_value() {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Primitive.string_value)
  return value_.string_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Primitive::release_string_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Primitive.string_value)
  if (has_string_value()) {
    clear_has_value();
    return value_.string_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Primitive::set_allocated_string_value(::std::string* string_value) {
  if (!has_string_value()) {
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (string_value != NULL) {
    set_has_string_value();
    value_.string_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        string_value);
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Primitive.string_value)
}

// bool boolean = 4;
inline bool Primitive::has_boolean() const {
  return value_case() == kBoolean;
}
inline void Primitive::set_has_boolean() {
  _oneof_case_[0] = kBoolean;
}
inline void Primitive::clear_boolean() {
  if (has_boolean()) {
    value_.boolean_ = false;
    clear_has_value();
  }
}
inline bool Primitive::boolean() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.boolean)
  if (has_boolean()) {
    return value_.boolean_;
  }
  return false;
}
inline void Primitive::set_boolean(bool value) {
  if (!has_boolean()) {
    clear_value();
    set_has_boolean();
  }
  value_.boolean_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.Primitive.boolean)
}

// .google.protobuf.Timestamp datetime = 5;
inline bool Primitive::has_datetime() const {
  return value_case() == kDatetime;
}
inline void Primitive::set_has_datetime() {
  _oneof_case_[0] = kDatetime;
}
inline ::google::protobuf::Timestamp* Primitive::release_datetime() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Primitive.datetime)
  if (has_datetime()) {
    clear_has_value();
      ::google::protobuf::Timestamp* temp = value_.datetime_;
    value_.datetime_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::protobuf::Timestamp& Primitive::datetime() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.datetime)
  return has_datetime()
      ? *value_.datetime_
      : *reinterpret_cast< ::google::protobuf::Timestamp*>(&::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Primitive::mutable_datetime() {
  if (!has_datetime()) {
    clear_value();
    set_has_datetime();
    value_.datetime_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Primitive.datetime)
  return value_.datetime_;
}

// .google.protobuf.Duration duration = 6;
inline bool Primitive::has_duration() const {
  return value_case() == kDuration;
}
inline void Primitive::set_has_duration() {
  _oneof_case_[0] = kDuration;
}
inline ::google::protobuf::Duration* Primitive::release_duration() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Primitive.duration)
  if (has_duration()) {
    clear_has_value();
      ::google::protobuf::Duration* temp = value_.duration_;
    value_.duration_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::protobuf::Duration& Primitive::duration() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Primitive.duration)
  return has_duration()
      ? *value_.duration_
      : *reinterpret_cast< ::google::protobuf::Duration*>(&::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* Primitive::mutable_duration() {
  if (!has_duration()) {
    clear_value();
    set_has_duration();
    value_.duration_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Primitive.duration)
  return value_.duration_;
}

inline bool Primitive::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Primitive::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Primitive::ValueCase Primitive::value_case() const {
  return Primitive::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Void

// -------------------------------------------------------------------

// Blob

// .flyteidl.core.BlobMetadata metadata = 1;
inline bool Blob::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline void Blob::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) {
    delete metadata_;
  }
  metadata_ = NULL;
}
inline const ::flyteidl::core::BlobMetadata& Blob::metadata() const {
  const ::flyteidl::core::BlobMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:flyteidl.core.Blob.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::flyteidl::core::BlobMetadata*>(
      &::flyteidl::core::_BlobMetadata_default_instance_);
}
inline ::flyteidl::core::BlobMetadata* Blob::release_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Blob.metadata)
  
  ::flyteidl::core::BlobMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::flyteidl::core::BlobMetadata* Blob::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::flyteidl::core::BlobMetadata;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Blob.metadata)
  return metadata_;
}
inline void Blob::set_allocated_metadata(::flyteidl::core::BlobMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete metadata_;
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Blob.metadata)
}

// string uri = 3;
inline void Blob::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Blob::uri() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Blob.uri)
  return uri_.GetNoArena();
}
inline void Blob::set_uri(const ::std::string& value) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Blob.uri)
}
#if LANG_CXX11
inline void Blob::set_uri(::std::string&& value) {
  
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Blob.uri)
}
#endif
inline void Blob::set_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Blob.uri)
}
inline void Blob::set_uri(const char* value, size_t size) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Blob.uri)
}
inline ::std::string* Blob::mutable_uri() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Blob.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Blob::release_uri() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Blob.uri)
  
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Blob::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
    
  } else {
    
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Blob.uri)
}

// -------------------------------------------------------------------

// BlobMetadata

// .flyteidl.core.BlobType type = 1;
inline bool BlobMetadata::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline const ::flyteidl::core::BlobType& BlobMetadata::type() const {
  const ::flyteidl::core::BlobType* p = type_;
  // @@protoc_insertion_point(field_get:flyteidl.core.BlobMetadata.type)
  return p != NULL ? *p : *reinterpret_cast<const ::flyteidl::core::BlobType*>(
      &::flyteidl::core::_BlobType_default_instance_);
}
inline ::flyteidl::core::BlobType* BlobMetadata::release_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BlobMetadata.type)
  
  ::flyteidl::core::BlobType* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::flyteidl::core::BlobType* BlobMetadata::mutable_type() {
  
  if (type_ == NULL) {
    type_ = new ::flyteidl::core::BlobType;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BlobMetadata.type)
  return type_;
}
inline void BlobMetadata::set_allocated_type(::flyteidl::core::BlobType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.BlobMetadata.type)
}

// -------------------------------------------------------------------

// Binary

// bytes value = 1;
inline void Binary::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Binary::value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Binary.value)
  return value_.GetNoArena();
}
inline void Binary::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Binary.value)
}
#if LANG_CXX11
inline void Binary::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Binary.value)
}
#endif
inline void Binary::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Binary.value)
}
inline void Binary::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Binary.value)
}
inline ::std::string* Binary::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Binary.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Binary::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Binary.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Binary::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Binary.value)
}

// string tag = 2;
inline void Binary::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Binary::tag() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Binary.tag)
  return tag_.GetNoArena();
}
inline void Binary::set_tag(const ::std::string& value) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Binary.tag)
}
#if LANG_CXX11
inline void Binary::set_tag(::std::string&& value) {
  
  tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Binary.tag)
}
#endif
inline void Binary::set_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Binary.tag)
}
inline void Binary::set_tag(const char* value, size_t size) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Binary.tag)
}
inline ::std::string* Binary::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Binary.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Binary::release_tag() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Binary.tag)
  
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Binary::set_allocated_tag(::std::string* tag) {
  if (tag != NULL) {
    
  } else {
    
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Binary.tag)
}

// -------------------------------------------------------------------

// Schema

// string uri = 1;
inline void Schema::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Schema::uri() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Schema.uri)
  return uri_.GetNoArena();
}
inline void Schema::set_uri(const ::std::string& value) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Schema.uri)
}
#if LANG_CXX11
inline void Schema::set_uri(::std::string&& value) {
  
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Schema.uri)
}
#endif
inline void Schema::set_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Schema.uri)
}
inline void Schema::set_uri(const char* value, size_t size) {
  
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Schema.uri)
}
inline ::std::string* Schema::mutable_uri() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Schema.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Schema::release_uri() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Schema.uri)
  
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Schema::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
    
  } else {
    
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Schema.uri)
}

// .flyteidl.core.SchemaType type = 3;
inline bool Schema::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline const ::flyteidl::core::SchemaType& Schema::type() const {
  const ::flyteidl::core::SchemaType* p = type_;
  // @@protoc_insertion_point(field_get:flyteidl.core.Schema.type)
  return p != NULL ? *p : *reinterpret_cast<const ::flyteidl::core::SchemaType*>(
      &::flyteidl::core::_SchemaType_default_instance_);
}
inline ::flyteidl::core::SchemaType* Schema::release_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Schema.type)
  
  ::flyteidl::core::SchemaType* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::flyteidl::core::SchemaType* Schema::mutable_type() {
  
  if (type_ == NULL) {
    type_ = new ::flyteidl::core::SchemaType;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Schema.type)
  return type_;
}
inline void Schema::set_allocated_type(::flyteidl::core::SchemaType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Schema.type)
}

// -------------------------------------------------------------------

// Scalar

// .flyteidl.core.Primitive primitive = 1;
inline bool Scalar::has_primitive() const {
  return value_case() == kPrimitive;
}
inline void Scalar::set_has_primitive() {
  _oneof_case_[0] = kPrimitive;
}
inline void Scalar::clear_primitive() {
  if (has_primitive()) {
    delete value_.primitive_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Primitive* Scalar::release_primitive() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.primitive)
  if (has_primitive()) {
    clear_has_value();
      ::flyteidl::core::Primitive* temp = value_.primitive_;
    value_.primitive_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flyteidl::core::Primitive& Scalar::primitive() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.primitive)
  return has_primitive()
      ? *value_.primitive_
      : *reinterpret_cast< ::flyteidl::core::Primitive*>(&::flyteidl::core::_Primitive_default_instance_);
}
inline ::flyteidl::core::Primitive* Scalar::mutable_primitive() {
  if (!has_primitive()) {
    clear_value();
    set_has_primitive();
    value_.primitive_ = new ::flyteidl::core::Primitive;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.primitive)
  return value_.primitive_;
}

// .flyteidl.core.Blob blob = 2;
inline bool Scalar::has_blob() const {
  return value_case() == kBlob;
}
inline void Scalar::set_has_blob() {
  _oneof_case_[0] = kBlob;
}
inline void Scalar::clear_blob() {
  if (has_blob()) {
    delete value_.blob_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Blob* Scalar::release_blob() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.blob)
  if (has_blob()) {
    clear_has_value();
      ::flyteidl::core::Blob* temp = value_.blob_;
    value_.blob_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flyteidl::core::Blob& Scalar::blob() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.blob)
  return has_blob()
      ? *value_.blob_
      : *reinterpret_cast< ::flyteidl::core::Blob*>(&::flyteidl::core::_Blob_default_instance_);
}
inline ::flyteidl::core::Blob* Scalar::mutable_blob() {
  if (!has_blob()) {
    clear_value();
    set_has_blob();
    value_.blob_ = new ::flyteidl::core::Blob;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.blob)
  return value_.blob_;
}

// .flyteidl.core.Binary binary = 3;
inline bool Scalar::has_binary() const {
  return value_case() == kBinary;
}
inline void Scalar::set_has_binary() {
  _oneof_case_[0] = kBinary;
}
inline void Scalar::clear_binary() {
  if (has_binary()) {
    delete value_.binary_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Binary* Scalar::release_binary() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.binary)
  if (has_binary()) {
    clear_has_value();
      ::flyteidl::core::Binary* temp = value_.binary_;
    value_.binary_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flyteidl::core::Binary& Scalar::binary() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.binary)
  return has_binary()
      ? *value_.binary_
      : *reinterpret_cast< ::flyteidl::core::Binary*>(&::flyteidl::core::_Binary_default_instance_);
}
inline ::flyteidl::core::Binary* Scalar::mutable_binary() {
  if (!has_binary()) {
    clear_value();
    set_has_binary();
    value_.binary_ = new ::flyteidl::core::Binary;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.binary)
  return value_.binary_;
}

// .flyteidl.core.Schema schema = 4;
inline bool Scalar::has_schema() const {
  return value_case() == kSchema;
}
inline void Scalar::set_has_schema() {
  _oneof_case_[0] = kSchema;
}
inline void Scalar::clear_schema() {
  if (has_schema()) {
    delete value_.schema_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Schema* Scalar::release_schema() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.schema)
  if (has_schema()) {
    clear_has_value();
      ::flyteidl::core::Schema* temp = value_.schema_;
    value_.schema_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flyteidl::core::Schema& Scalar::schema() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.schema)
  return has_schema()
      ? *value_.schema_
      : *reinterpret_cast< ::flyteidl::core::Schema*>(&::flyteidl::core::_Schema_default_instance_);
}
inline ::flyteidl::core::Schema* Scalar::mutable_schema() {
  if (!has_schema()) {
    clear_value();
    set_has_schema();
    value_.schema_ = new ::flyteidl::core::Schema;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.schema)
  return value_.schema_;
}

// .flyteidl.core.Void none_type = 5;
inline bool Scalar::has_none_type() const {
  return value_case() == kNoneType;
}
inline void Scalar::set_has_none_type() {
  _oneof_case_[0] = kNoneType;
}
inline void Scalar::clear_none_type() {
  if (has_none_type()) {
    delete value_.none_type_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Void* Scalar::release_none_type() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.none_type)
  if (has_none_type()) {
    clear_has_value();
      ::flyteidl::core::Void* temp = value_.none_type_;
    value_.none_type_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flyteidl::core::Void& Scalar::none_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.none_type)
  return has_none_type()
      ? *value_.none_type_
      : *reinterpret_cast< ::flyteidl::core::Void*>(&::flyteidl::core::_Void_default_instance_);
}
inline ::flyteidl::core::Void* Scalar::mutable_none_type() {
  if (!has_none_type()) {
    clear_value();
    set_has_none_type();
    value_.none_type_ = new ::flyteidl::core::Void;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.none_type)
  return value_.none_type_;
}

// .flyteidl.core.Error error = 6;
inline bool Scalar::has_error() const {
  return value_case() == kError;
}
inline void Scalar::set_has_error() {
  _oneof_case_[0] = kError;
}
inline ::flyteidl::core::Error* Scalar::release_error() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.error)
  if (has_error()) {
    clear_has_value();
      ::flyteidl::core::Error* temp = value_.error_;
    value_.error_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flyteidl::core::Error& Scalar::error() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.error)
  return has_error()
      ? *value_.error_
      : *reinterpret_cast< ::flyteidl::core::Error*>(&::flyteidl::core::_Error_default_instance_);
}
inline ::flyteidl::core::Error* Scalar::mutable_error() {
  if (!has_error()) {
    clear_value();
    set_has_error();
    value_.error_ = new ::flyteidl::core::Error;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.error)
  return value_.error_;
}

// .google.protobuf.Struct generic = 7;
inline bool Scalar::has_generic() const {
  return value_case() == kGeneric;
}
inline void Scalar::set_has_generic() {
  _oneof_case_[0] = kGeneric;
}
inline ::google::protobuf::Struct* Scalar::release_generic() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Scalar.generic)
  if (has_generic()) {
    clear_has_value();
      ::google::protobuf::Struct* temp = value_.generic_;
    value_.generic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::protobuf::Struct& Scalar::generic() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Scalar.generic)
  return has_generic()
      ? *value_.generic_
      : *reinterpret_cast< ::google::protobuf::Struct*>(&::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* Scalar::mutable_generic() {
  if (!has_generic()) {
    clear_value();
    set_has_generic();
    value_.generic_ = new ::google::protobuf::Struct;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Scalar.generic)
  return value_.generic_;
}

inline bool Scalar::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Scalar::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Scalar::ValueCase Scalar::value_case() const {
  return Scalar::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Literal

// .flyteidl.core.Scalar scalar = 1;
inline bool Literal::has_scalar() const {
  return value_case() == kScalar;
}
inline void Literal::set_has_scalar() {
  _oneof_case_[0] = kScalar;
}
inline void Literal::clear_scalar() {
  if (has_scalar()) {
    delete value_.scalar_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Scalar* Literal::release_scalar() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.scalar)
  if (has_scalar()) {
    clear_has_value();
      ::flyteidl::core::Scalar* temp = value_.scalar_;
    value_.scalar_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flyteidl::core::Scalar& Literal::scalar() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.scalar)
  return has_scalar()
      ? *value_.scalar_
      : *reinterpret_cast< ::flyteidl::core::Scalar*>(&::flyteidl::core::_Scalar_default_instance_);
}
inline ::flyteidl::core::Scalar* Literal::mutable_scalar() {
  if (!has_scalar()) {
    clear_value();
    set_has_scalar();
    value_.scalar_ = new ::flyteidl::core::Scalar;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.scalar)
  return value_.scalar_;
}

// .flyteidl.core.LiteralCollection collection = 2;
inline bool Literal::has_collection() const {
  return value_case() == kCollection;
}
inline void Literal::set_has_collection() {
  _oneof_case_[0] = kCollection;
}
inline void Literal::clear_collection() {
  if (has_collection()) {
    delete value_.collection_;
    clear_has_value();
  }
}
inline ::flyteidl::core::LiteralCollection* Literal::release_collection() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.collection)
  if (has_collection()) {
    clear_has_value();
      ::flyteidl::core::LiteralCollection* temp = value_.collection_;
    value_.collection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flyteidl::core::LiteralCollection& Literal::collection() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.collection)
  return has_collection()
      ? *value_.collection_
      : *reinterpret_cast< ::flyteidl::core::LiteralCollection*>(&::flyteidl::core::_LiteralCollection_default_instance_);
}
inline ::flyteidl::core::LiteralCollection* Literal::mutable_collection() {
  if (!has_collection()) {
    clear_value();
    set_has_collection();
    value_.collection_ = new ::flyteidl::core::LiteralCollection;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.collection)
  return value_.collection_;
}

// .flyteidl.core.LiteralMap map = 3;
inline bool Literal::has_map() const {
  return value_case() == kMap;
}
inline void Literal::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void Literal::clear_map() {
  if (has_map()) {
    delete value_.map_;
    clear_has_value();
  }
}
inline ::flyteidl::core::LiteralMap* Literal::release_map() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Literal.map)
  if (has_map()) {
    clear_has_value();
      ::flyteidl::core::LiteralMap* temp = value_.map_;
    value_.map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flyteidl::core::LiteralMap& Literal::map() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Literal.map)
  return has_map()
      ? *value_.map_
      : *reinterpret_cast< ::flyteidl::core::LiteralMap*>(&::flyteidl::core::_LiteralMap_default_instance_);
}
inline ::flyteidl::core::LiteralMap* Literal::mutable_map() {
  if (!has_map()) {
    clear_value();
    set_has_map();
    value_.map_ = new ::flyteidl::core::LiteralMap;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Literal.map)
  return value_.map_;
}

inline bool Literal::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Literal::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Literal::ValueCase Literal::value_case() const {
  return Literal::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LiteralCollection

// repeated .flyteidl.core.Literal literals = 1;
inline int LiteralCollection::literals_size() const {
  return literals_.size();
}
inline void LiteralCollection::clear_literals() {
  literals_.Clear();
}
inline const ::flyteidl::core::Literal& LiteralCollection::literals(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LiteralCollection.literals)
  return literals_.Get(index);
}
inline ::flyteidl::core::Literal* LiteralCollection::mutable_literals(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LiteralCollection.literals)
  return literals_.Mutable(index);
}
inline ::flyteidl::core::Literal* LiteralCollection::add_literals() {
  // @@protoc_insertion_point(field_add:flyteidl.core.LiteralCollection.literals)
  return literals_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Literal >*
LiteralCollection::mutable_literals() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.LiteralCollection.literals)
  return &literals_;
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::Literal >&
LiteralCollection::literals() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.LiteralCollection.literals)
  return literals_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LiteralMap

// map<string, .flyteidl.core.Literal> literals = 1;
inline int LiteralMap::literals_size() const {
  return literals_.size();
}
inline void LiteralMap::clear_literals() {
  literals_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::flyteidl::core::Literal >&
LiteralMap::literals() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.LiteralMap.literals)
  return literals_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::flyteidl::core::Literal >*
LiteralMap::mutable_literals() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.LiteralMap.literals)
  return literals_.MutableMap();
}

// -------------------------------------------------------------------

// BindingDataCollection

// repeated .flyteidl.core.BindingData bindings = 1;
inline int BindingDataCollection::bindings_size() const {
  return bindings_.size();
}
inline void BindingDataCollection::clear_bindings() {
  bindings_.Clear();
}
inline const ::flyteidl::core::BindingData& BindingDataCollection::bindings(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingDataCollection.bindings)
  return bindings_.Get(index);
}
inline ::flyteidl::core::BindingData* BindingDataCollection::mutable_bindings(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingDataCollection.bindings)
  return bindings_.Mutable(index);
}
inline ::flyteidl::core::BindingData* BindingDataCollection::add_bindings() {
  // @@protoc_insertion_point(field_add:flyteidl.core.BindingDataCollection.bindings)
  return bindings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::BindingData >*
BindingDataCollection::mutable_bindings() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.BindingDataCollection.bindings)
  return &bindings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::BindingData >&
BindingDataCollection::bindings() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.BindingDataCollection.bindings)
  return bindings_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BindingDataMap

// map<string, .flyteidl.core.BindingData> bindings = 1;
inline int BindingDataMap::bindings_size() const {
  return bindings_.size();
}
inline void BindingDataMap::clear_bindings() {
  bindings_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::flyteidl::core::BindingData >&
BindingDataMap::bindings() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.BindingDataMap.bindings)
  return bindings_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::flyteidl::core::BindingData >*
BindingDataMap::mutable_bindings() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.BindingDataMap.bindings)
  return bindings_.MutableMap();
}

// -------------------------------------------------------------------

// BindingData

// .flyteidl.core.Scalar scalar = 1;
inline bool BindingData::has_scalar() const {
  return value_case() == kScalar;
}
inline void BindingData::set_has_scalar() {
  _oneof_case_[0] = kScalar;
}
inline void BindingData::clear_scalar() {
  if (has_scalar()) {
    delete value_.scalar_;
    clear_has_value();
  }
}
inline ::flyteidl::core::Scalar* BindingData::release_scalar() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BindingData.scalar)
  if (has_scalar()) {
    clear_has_value();
      ::flyteidl::core::Scalar* temp = value_.scalar_;
    value_.scalar_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flyteidl::core::Scalar& BindingData::scalar() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingData.scalar)
  return has_scalar()
      ? *value_.scalar_
      : *reinterpret_cast< ::flyteidl::core::Scalar*>(&::flyteidl::core::_Scalar_default_instance_);
}
inline ::flyteidl::core::Scalar* BindingData::mutable_scalar() {
  if (!has_scalar()) {
    clear_value();
    set_has_scalar();
    value_.scalar_ = new ::flyteidl::core::Scalar;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingData.scalar)
  return value_.scalar_;
}

// .flyteidl.core.BindingDataCollection collection = 2;
inline bool BindingData::has_collection() const {
  return value_case() == kCollection;
}
inline void BindingData::set_has_collection() {
  _oneof_case_[0] = kCollection;
}
inline void BindingData::clear_collection() {
  if (has_collection()) {
    delete value_.collection_;
    clear_has_value();
  }
}
inline ::flyteidl::core::BindingDataCollection* BindingData::release_collection() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BindingData.collection)
  if (has_collection()) {
    clear_has_value();
      ::flyteidl::core::BindingDataCollection* temp = value_.collection_;
    value_.collection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flyteidl::core::BindingDataCollection& BindingData::collection() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingData.collection)
  return has_collection()
      ? *value_.collection_
      : *reinterpret_cast< ::flyteidl::core::BindingDataCollection*>(&::flyteidl::core::_BindingDataCollection_default_instance_);
}
inline ::flyteidl::core::BindingDataCollection* BindingData::mutable_collection() {
  if (!has_collection()) {
    clear_value();
    set_has_collection();
    value_.collection_ = new ::flyteidl::core::BindingDataCollection;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingData.collection)
  return value_.collection_;
}

// .flyteidl.core.OutputReference promise = 3;
inline bool BindingData::has_promise() const {
  return value_case() == kPromise;
}
inline void BindingData::set_has_promise() {
  _oneof_case_[0] = kPromise;
}
inline ::flyteidl::core::OutputReference* BindingData::release_promise() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BindingData.promise)
  if (has_promise()) {
    clear_has_value();
      ::flyteidl::core::OutputReference* temp = value_.promise_;
    value_.promise_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flyteidl::core::OutputReference& BindingData::promise() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingData.promise)
  return has_promise()
      ? *value_.promise_
      : *reinterpret_cast< ::flyteidl::core::OutputReference*>(&::flyteidl::core::_OutputReference_default_instance_);
}
inline ::flyteidl::core::OutputReference* BindingData::mutable_promise() {
  if (!has_promise()) {
    clear_value();
    set_has_promise();
    value_.promise_ = new ::flyteidl::core::OutputReference;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingData.promise)
  return value_.promise_;
}

// .flyteidl.core.BindingDataMap map = 4;
inline bool BindingData::has_map() const {
  return value_case() == kMap;
}
inline void BindingData::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void BindingData::clear_map() {
  if (has_map()) {
    delete value_.map_;
    clear_has_value();
  }
}
inline ::flyteidl::core::BindingDataMap* BindingData::release_map() {
  // @@protoc_insertion_point(field_release:flyteidl.core.BindingData.map)
  if (has_map()) {
    clear_has_value();
      ::flyteidl::core::BindingDataMap* temp = value_.map_;
    value_.map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::flyteidl::core::BindingDataMap& BindingData::map() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.BindingData.map)
  return has_map()
      ? *value_.map_
      : *reinterpret_cast< ::flyteidl::core::BindingDataMap*>(&::flyteidl::core::_BindingDataMap_default_instance_);
}
inline ::flyteidl::core::BindingDataMap* BindingData::mutable_map() {
  if (!has_map()) {
    clear_value();
    set_has_map();
    value_.map_ = new ::flyteidl::core::BindingDataMap;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.BindingData.map)
  return value_.map_;
}

inline bool BindingData::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void BindingData::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline BindingData::ValueCase BindingData::value_case() const {
  return BindingData::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Binding

// string var = 1;
inline void Binding::clear_var() {
  var_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Binding::var() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Binding.var)
  return var_.GetNoArena();
}
inline void Binding::set_var(const ::std::string& value) {
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Binding.var)
}
#if LANG_CXX11
inline void Binding::set_var(::std::string&& value) {
  
  var_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Binding.var)
}
#endif
inline void Binding::set_var(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Binding.var)
}
inline void Binding::set_var(const char* value, size_t size) {
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Binding.var)
}
inline ::std::string* Binding::mutable_var() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Binding.var)
  return var_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Binding::release_var() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Binding.var)
  
  return var_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Binding::set_allocated_var(::std::string* var) {
  if (var != NULL) {
    
  } else {
    
  }
  var_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), var);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Binding.var)
}

// .flyteidl.core.BindingData binding = 2;
inline bool Binding::has_binding() const {
  return this != internal_default_instance() && binding_ != NULL;
}
inline void Binding::clear_binding() {
  if (GetArenaNoVirtual() == NULL && binding_ != NULL) {
    delete binding_;
  }
  binding_ = NULL;
}
inline const ::flyteidl::core::BindingData& Binding::binding() const {
  const ::flyteidl::core::BindingData* p = binding_;
  // @@protoc_insertion_point(field_get:flyteidl.core.Binding.binding)
  return p != NULL ? *p : *reinterpret_cast<const ::flyteidl::core::BindingData*>(
      &::flyteidl::core::_BindingData_default_instance_);
}
inline ::flyteidl::core::BindingData* Binding::release_binding() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Binding.binding)
  
  ::flyteidl::core::BindingData* temp = binding_;
  binding_ = NULL;
  return temp;
}
inline ::flyteidl::core::BindingData* Binding::mutable_binding() {
  
  if (binding_ == NULL) {
    binding_ = new ::flyteidl::core::BindingData;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Binding.binding)
  return binding_;
}
inline void Binding::set_allocated_binding(::flyteidl::core::BindingData* binding) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete binding_;
  }
  if (binding) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      binding = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, binding, submessage_arena);
    }
    
  } else {
    
  }
  binding_ = binding;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Binding.binding)
}

// -------------------------------------------------------------------

// KeyValuePair

// string key = 1;
inline void KeyValuePair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValuePair::key() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.KeyValuePair.key)
  return key_.GetNoArena();
}
inline void KeyValuePair::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.KeyValuePair.key)
}
#if LANG_CXX11
inline void KeyValuePair::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.KeyValuePair.key)
}
#endif
inline void KeyValuePair::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.KeyValuePair.key)
}
inline void KeyValuePair::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.KeyValuePair.key)
}
inline ::std::string* KeyValuePair::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.KeyValuePair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValuePair::release_key() {
  // @@protoc_insertion_point(field_release:flyteidl.core.KeyValuePair.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValuePair::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.KeyValuePair.key)
}

// string value = 2;
inline void KeyValuePair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValuePair::value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.KeyValuePair.value)
  return value_.GetNoArena();
}
inline void KeyValuePair::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.KeyValuePair.value)
}
#if LANG_CXX11
inline void KeyValuePair::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.KeyValuePair.value)
}
#endif
inline void KeyValuePair::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.KeyValuePair.value)
}
inline void KeyValuePair::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.KeyValuePair.value)
}
inline ::std::string* KeyValuePair::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.KeyValuePair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValuePair::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.KeyValuePair.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValuePair::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.KeyValuePair.value)
}

// -------------------------------------------------------------------

// RetryStrategy

// uint32 retries = 5;
inline void RetryStrategy::clear_retries() {
  retries_ = 0u;
}
inline ::google::protobuf::uint32 RetryStrategy::retries() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.RetryStrategy.retries)
  return retries_;
}
inline void RetryStrategy::set_retries(::google::protobuf::uint32 value) {
  
  retries_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.RetryStrategy.retries)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace flyteidl

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_flyteidl_2fcore_2fliterals_2eproto__INCLUDED
